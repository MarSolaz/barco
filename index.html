<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<title>Barco de Papel — Viaje</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{ --ui-font:16px/1.25 system-ui, -apple-system, "Segoe UI", Roboto, Arial; --card-bg: rgba(255,255,255,0.98); }
  html,body{height:100%;margin:0;background:#e6f5ff;font:var(--ui-font);-webkit-font-smoothing:antialiased;color:#0c2530}
  canvas{display:block; width:100%; height:100vh; background:transparent}

  /* HUD */
  .hud{position:fixed; left:16px; top:14px; z-index:120; background:transparent; padding:8px 10px; border-radius:10px; font-weight:700; box-shadow:none; }

  /* music toggle */
  .music-toggle{position:fixed; right:18px; bottom:18px; z-index:120; width:46px; height:46px; display:flex;align-items:center;justify-content:center;border-radius:12px;background:rgba(255,255,255,0.95); box-shadow:0 10px 30px rgba(9,12,14,0.06); cursor:pointer}
  .music-toggle.muted{opacity:0.55}

  /* Centered minimal menu */
  .menu-wrap{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:200; pointer-events:auto; }
  .menu-card{ width:380px; max-width:94%; padding:20px 22px; border-radius:14px; background:transparent; box-shadow:none ; text-align:center; }
  .menu-title{ margin:0; font-size:22px; font-weight:800; color:#aa8534 }
  .menu-sub{ margin:8px 0 18px; color:#5f6b71; font-size:13px }

  .modes{ display:flex; gap:10px; justify-content:center; margin-bottom:14px; }
  .mode-btn{ padding:9px 14px; border-radius:10px; cursor:pointer; border:1px solid transparent; background:transparent; color:#0b2630; font-weight:700; min-width:130px; }
  .mode-btn.active{ background:#aa8534; color:white; box-shadow:0 12px 30px rgba(49, 49, 49, 0.12) }

  .fugaz-row{ display:flex; align-items:center; justify-content:center; gap:10px; margin-bottom:12px; }
  .time-btn{ width:44px; height:44px; border-radius:10px; background:white; border:1px solid #e6e9ec; cursor:pointer; font-size:20px; line-height:0; display:flex; align-items:center; justify-content:center }
  .minutes-display{ min-width:72px; text-align:center; font-weight:800; font-size:16px; padding:6px 8px; border-radius:10px; background:#fbfbfb; border:1px solid #eef2f4; }

  .start-btn{ display:block; width:100%; margin-top:6px; padding:11px 12px; border-radius:12px; background:#aa8534; color:#fff; font-weight:800; font-size:15px; border:none; cursor:pointer; box-shadow:0 10px 28px rgba(7,32,42,0.12) }

  /* Game over overlay */
  .overlay{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:300; pointer-events:auto; }
  .overlay .card{ padding:22px; border-radius:12px; background:transparent ; color:white; text-align:center; box-shadow:none; }
  .overlay .hint{ margin-top:12px; color:#cdd6da; font-size:13px }

  @media (max-width:420px){
    .menu-card{ padding:14px }
    .minutes-display{ min-width:56px; font-size:15px }
  }
</style>
</head>
<body>

<!-- HUD -->
<div class="hud" id="hud">Score: 0</div>

<!-- Canvas -->
<canvas id="game"></canvas>

<!-- Música (pon aquí tu archivo drop.mp3) -->
<audio id="bgMusic" src="drop.mp3" loop preload="auto"></audio>
<div class="music-toggle muted" id="musicBtn" title="Activar / desactivar música" aria-pressed="false">
  <svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true"><g fill="none" stroke="#111" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><path d="M5 15V9a1 1 0 0 1 1-1h3l4-4v14l-4-4H6a1 1 0 0 1-1-1z"/></g></svg>
</div>

<!-- Menú centrado -->
<div class="menu-wrap" id="menu">
  <div class="menu-card" role="dialog" aria-label="Seleccionar modo">
    <h3 class="menu-title">Elegí tu viaje</h3>
    <div class="menu-sub">Relajá en un viaje eterno, o disfrutá un viaje fugaz con duración limitada.</div>

    <div class="modes" role="tablist" aria-label="Modos">
      <button class="mode-btn active" id="btnEterno" data-mode="eterno" aria-pressed="true">Viaje eterno</button>
      <button class="mode-btn" id="btnFugaz" data-mode="fugaz" aria-pressed="false">Viaje fugaz</button>
    </div>

    <div id="fugazControls" style="display:none;">
      <div class="fugaz-row" aria-hidden="false">
        <button class="time-btn" id="minDown" aria-label="Disminuir minutos">−</button>
        <div class="minutes-display" id="minutesDisplay" aria-live="polite">3</div>
        <button class="time-btn" id="minUp" aria-label="Aumentar minutos">+</button>
      </div>
      <div style="font-size:13px;color:#6b7780;margin-bottom:6px">Duración en minutos (al terminar se mostrará el puntaje)</div>
    </div>

    <button class="start-btn" id="startBtn">Comenzar</button>
  </div>
</div>

<!-- Game Over -->
<div class="overlay" id="gameOver" style="display:none;">
  <div class="card">
    <div style="font-size:20px;font-weight:800" id="finalTitle">Fin del viaje</div>
    <div style="font-size:18px;margin-top:8px" id="finalScore">Puntaje: 0</div>
    <div class="hint">Presioná cualquier tecla o tocá para volver al inicio</div>
  </div>
</div>

<script>
(() => {
  // ----------------- CONFIG -----------------
  const startAt = 0.01;     // momento relativo donde empieza el amarilleo (fracción del total)
  const speedFactor = 3;    // multiplicador de la progresión de envejecimiento
  const sinkSlowFactor = 1.0;

  // ----------------- SETUP -----------------
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: false });
  const hud = document.getElementById('hud');
  const menu = document.getElementById('menu');
  const fugazControls = document.getElementById('fugazControls');
  const minutesDisplay = document.getElementById('minutesDisplay');
  const startBtn = document.getElementById('startBtn');
  const btnEterno = document.getElementById('btnEterno');
  const btnFugaz = document.getElementById('btnFugaz');
  const gameOverEl = document.getElementById('gameOver');
  const finalScoreEl = document.getElementById('finalScore');
  const music = document.getElementById('bgMusic');
  const musicBtn = document.getElementById('musicBtn');

  function fit(){ canvas.width = innerWidth; canvas.height = innerHeight; }
  addEventListener('resize', fit, { passive:true }); fit();

  // ----------------- AUDIO -----------------
  music.volume = 0.28; music.loop = true;
  let musicAllowed = false;
  async function tryPlayMusicOnce(){
    if(musicAllowed) return;
    try {
      const p = music.play();
      if(p && p.then) await p;
      musicAllowed = true;
      musicBtn.classList.remove('muted');
      musicBtn.setAttribute('aria-pressed','true');
    } catch(e){
      // autoplay blocked
    }
  }
  function toggleMusic(){
    try {
      if(music.paused) {
        music.play().catch(()=>{});
        musicBtn.classList.remove('muted');
        musicBtn.setAttribute('aria-pressed','true');
        musicAllowed = true;
      } else {
        music.pause();
        musicBtn.classList.add('muted');
        musicBtn.setAttribute('aria-pressed','false');
      }
    } catch(e){}
  }
  addEventListener('pointerdown', tryPlayMusicOnce, {passive:true});
  addEventListener('keydown', tryPlayMusicOnce, {passive:true});
  musicBtn.addEventListener('click', (e)=>{ e.stopPropagation(); toggleMusic(); });

  // ----------------- UTILS -----------------
  function hexToRgb(h){ h=h.replace('#',''); return {r:parseInt(h.slice(0,2),16), g:parseInt(h.slice(2,4),16), b:parseInt(h.slice(4,6),16)}; }
  function lerpColor(a,b,t){ const A=hexToRgb(a), B=hexToRgb(b); const r=Math.round(A.r+(B.r-A.r)*t); const g=Math.round(A.g+(B.g-A.g)*t); const bb=Math.round(A.b+(B.b-A.b)*t); return `rgb(${r},${g},${bb})`; }
  function clamp(v,a=0,b=1){ return Math.max(a, Math.min(b, v)); }

  // ----------------- WORLD -----------------
  let frame = 0;
  let score = 0;
  const targetFPS = 60;
  const phaseDurationFrames = targetFPS * 20;

  const dayPhases = [
    { name:'amanecer', sky:'#FFD9C2', river:'#A7D9FF', hills:['#FFE8B8','#FBD3B3','#FFE0A8'] },
    { name:'día',     sky:'#A6DBF5', river:'#8ECFFF', hills:['#CFF3C9','#BFEFBE','#A7E6A0'] },
    { name:'atardecer',sky:'#FFC7B5', river:'#9FD6FF', hills:['#F6B1B1','#F6D0B1','#F3E3A8'] },
    { name:'noche',   sky:'#142231', river:'#334E7A', hills:['#2B344E','#2E3A5A','#32406A'] }
  ];

  class Hill { constructor(baseColor,speed,amp,y){ this.baseColor=baseColor; this.speed=speed; this.amp=amp; this.yFactor=y; this.offset=Math.random()*1000 } draw(color){ this.offset+=this.speed; ctx.fillStyle=color; ctx.beginPath(); ctx.moveTo(0,canvas.height); for(let x=0;x<=canvas.width;x+=6){ const y = canvas.height*this.yFactor + Math.sin((x*0.008)+(this.offset*0.01))*this.amp; ctx.lineTo(x,y); } ctx.lineTo(canvas.width,canvas.height); ctx.closePath(); ctx.fill(); } }

  class Particle { constructor(){ this.reset(); } reset(){ this.x=Math.random()*canvas.width; this.y=Math.random()*canvas.height; this.r=Math.random()*1.6+0.6; this.vx=(Math.random()-0.5)*0.25; this.vy=(Math.random()-0.2)*0.25; this.alpha=Math.random()*0.6+0.15 } update(){ this.x+=this.vx; this.y+=this.vy; if(this.x<-10) this.x=canvas.width+10; if(this.x>canvas.width+10) this.x=-10; if(this.y<-10) this.y=canvas.height+10; if(this.y>canvas.height+10) this.y=-10 } draw(){ ctx.globalAlpha=this.alpha; ctx.beginPath(); ctx.fillStyle='#fff'; ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1 } }

  function riverY(x){ const t = frame*0.018; return canvas.height*0.74 + Math.sin(0.009*x + t)*24 + Math.sin(0.015*x + t*0.6)*8; }

  // Boat class (fixed: no flashing to white, monotonic agedIntensity)
  class Boat {
    constructor(x){
      this.x = x;
      this.y = riverY(x)-30;
      this.w=72; this.h=36; this.vy=0; this.gravity=0.8; this.jumpForce=-14; this.tilt=0;
      this.agedIntensity = 0; // 0..1, monotonic (never decreases during a round)
      this.sinking = false; this.sinkProgress = 0;
    }
    update(){
      if(this.sinking){
        this.sinkProgress += 0.0025 * (1 / Math.max(0.01, sinkSlowFactor));
        this.y += 0.6 + this.sinkProgress * (2.5 * sinkSlowFactor);
        this.tilt += 0.0025 * sinkSlowFactor;
        return;
      }
      this.vy += this.gravity;
      this.y += this.vy;
      const base = riverY(this.x) - this.h;
      if(this.y > base){ this.y = base; this.vy = 0; }
      this.tilt = Math.max(-0.35, Math.min(0.35, this.vy * 0.03));
    }
    draw(){
      // sombra
      ctx.save(); ctx.translate(this.x, this.y + this.h*0.6); ctx.rotate(this.tilt*0.3); ctx.globalAlpha=0.12; ctx.fillStyle='#000'; ctx.beginPath(); ctx.ellipse(0,6,this.w*0.45,6,0,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; ctx.restore();

      // mezcla: blanco -> amarillo pálido -> marrón cálido (funciona aunque envejezca)
      const mix = (a,b,t)=>{ const A=hexToRgb(a), B=hexToRgb(b); const r=Math.round(A.r+(B.r-A.r)*t); const g=Math.round(A.g+(B.g-A.g)*t); const bb=Math.round(A.b+(B.b-A.b)*t); return `rgb(${r},${g},${bb})`; };
      // we use agedIntensity only as a modifier of the gradient stops, but the gradient itself ensures no white flash
      const ai = clamp(this.agedIntensity, 0, 1);
      const c0 = mix('#ffffff','#fff5c9', Math.min(1, ai * 0.95));
      const c1 = mix('#f1f1f1','#f1d79a', Math.min(1, ai * 0.95));
      const c2 = mix('#dcdcdc','#6b4a2a', Math.min(1, ai));
      const gx = ctx.createLinearGradient(this.x - this.w/2, this.y - this.h*0.2, this.x + this.w/2, this.y + this.h);
      gx.addColorStop(0, c0); gx.addColorStop(0.6, c1); gx.addColorStop(1, c2);

      ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.tilt);
      ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(this.w*0.45, this.h*0.75); ctx.lineTo(this.w*0.06, this.h*0.6); ctx.lineTo(-this.w*0.06, this.h*0.6); ctx.lineTo(-this.w*0.45, this.h*0.75); ctx.closePath();
      ctx.fillStyle = gx; ctx.fill();

      if(ai > 0.02){
        ctx.globalAlpha = ai * 0.18;
        ctx.fillStyle = '#000';
        ctx.beginPath(); ctx.moveTo(-this.w*0.45, this.h*0.75); ctx.lineTo(this.w*0.45, this.h*0.75); ctx.lineTo(this.w*0.08, this.h*0.9); ctx.lineTo(-this.w*0.08, this.h*0.9); ctx.closePath(); ctx.fill(); ctx.globalAlpha=1;
      }
      ctx.restore();
    }
    jump(){ if(!this.sinking) this.vy = this.jumpForce; }
    rect(){ return { left:this.x-this.w/2, right:this.x+this.w/2, top:this.y, bottom:this.y+this.h }; }
    // helper to force full aging (used when sinking)
    forceFullyAged(){ this.agedIntensity = 1; }
  }

  // arrays y objetos
  let boat = new Boat(160);
  const hills = [ new Hill('#000',0.15,28,0.45), new Hill('#000',0.28,18,0.55), new Hill('#000',0.55,12,0.66) ];
  const particles = Array.from({length:90},()=>new Particle());
  let rocks = [], drops = [], ripples = [];

  // RainDrop, SnowFlake, Ripple, Rock (kept original logic, cleaned)
  class RainDrop { constructor(){ this.reset(); } reset(){ this.x=Math.random()*canvas.width; this.y=-10-Math.random()*200; this.vy=8+Math.random()*6; this.len=8+Math.random()*10; this.alpha=0.2+Math.random()*0.4 } update(){ this.x += (Math.random()-0.5)*0.6; this.y += this.vy } draw(){ ctx.globalAlpha=this.alpha; ctx.beginPath(); ctx.strokeStyle='rgba(255,255,255,0.65)'; ctx.lineWidth=1; ctx.moveTo(this.x,this.y); ctx.lineTo(this.x,this.y+this.len); ctx.stroke(); ctx.globalAlpha=1 } hitSurface(){ return this.y >= riverY(this.x); } }
  class SnowFlake { constructor(){ this.x=Math.random()*canvas.width; this.y=-10-Math.random()*200; this.vy=0.6+Math.random()*1.2; this.vx=(Math.random()-0.5)*0.6; this.r=1.8+Math.random()*2.6; this.alpha=0.6+Math.random()*0.4 } update(){ this.x+=this.vx; this.y+=this.vy; this.vx+=(Math.random()-0.5)*0.04 } draw(){ ctx.globalAlpha=this.alpha; ctx.beginPath(); ctx.fillStyle='rgba(255,255,255,0.95)'; ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1 } hitSurface(){ return this.y >= riverY(this.x); } }
  class Ripple { constructor(x){ this.x = x; this.y = riverY(x); this.r = 2 + Math.random()*2; this.life = 0.9 } update(){ this.r += 0.9 + Math.random()*0.6; this.life -= 0.06; if(this.life<0) this.life=0 } draw(){ if(this.life<=0) return; ctx.globalAlpha=this.life*0.9; ctx.strokeStyle='rgba(255,255,255,0.35)'; ctx.lineWidth=Math.max(1,this.life*2); ctx.beginPath(); ctx.ellipse(this.x,this.y+2,this.r*1.1,this.r*0.4,0,0,Math.PI*2); ctx.stroke(); ctx.globalAlpha=1 } alive(){ return this.life>0.02 } }

  class Rock {
    constructor(){ this.r=12+Math.random()*20; this.x=canvas.width+this.r+Math.random()*200; this.speed=3.6+Math.random()*0.8; this.scored=false; this.seed=Math.random()*999; this.seed2=Math.random()*999; this.tint=(Math.random()*30-15); }
    update(){ this.x-=this.speed }
    cx(){ return this.x; }
    cy(){ return riverY(this.x)-(this.r*0.45); }
    offscreen(){ return this.x+this.r < -50; }
    draw(){
      const cx=this.cx(), cy=this.cy();
      const g=ctx.createLinearGradient(0,cy-this.r,0,cy+this.r);
      const top = Math.max(40,120+this.tint-40);
      const mid = Math.max(30,90+this.tint-30);
      const bot = Math.max(10,40+this.tint-40);
      g.addColorStop(0, `rgb(${top},${top},${top})`);
      g.addColorStop(0.6, `rgb(${mid},${mid},${mid})`);
      g.addColorStop(1, `rgb(${bot},${bot},${bot})`);
      ctx.fillStyle=g;
      ctx.beginPath();
      const steps=34;
      for(let i=0;i<=steps;i++){
        const a=(i/steps)*Math.PI*2;
        const noise=0.18*Math.sin(a*3+this.seed)+0.10*Math.sin(a*5+this.seed2)+0.06*Math.sin(a*7-this.seed*0.3);
        const rad=this.r*(1+noise);
        const px=cx+Math.cos(a)*rad;
        const py=cy+Math.sin(a)*rad;
        if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.closePath();
      ctx.fill();

      // base/ledge under rock
      ctx.save();
      ctx.beginPath();
      const left=cx-this.r*1.05;
      const right=cx+this.r*1.05;
      const stepX = Math.max(6,Math.round(this.r*0.8));
      for(let x=left;x<=right;x+=stepX){
        const wave = Math.sin((x*0.01)+frame*0.02+this.seed*0.01)*(this.r*0.18);
        const y = riverY(cx+(x-cx)) - (this.r*0.02) + wave;
        if(x===left) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.lineTo(right,canvas.height);
      ctx.lineTo(left,canvas.height);
      ctx.closePath();
      ctx.globalAlpha=0.95;
      ctx.fillStyle = `rgba(${Math.max(8,bot-10)},${Math.max(8,bot-10)},${Math.max(8,bot-10)},1)`;
      ctx.fill();
      ctx.globalAlpha=1;
      ctx.restore();
    }
    collide(boatRect){
      const cx=this.cx(), cy=this.cy(), r=this.r;
      const closestX = Math.max(boatRect.left, Math.min(cx, boatRect.right));
      const closestY = Math.max(boatRect.top, Math.min(cy, boatRect.bottom));
      const dx=cx-closestX, dy=cy-closestY;
      return (dx*dx + dy*dy) <= (r*r);
    }
  }

  // ----------------- CONTROLS -----------------
  function onJump(){ if(!gameStarted || gameOver) return; boat.jump(); }
  addEventListener('keydown',(e)=>{ if((e.code==='Space' || e.key===' ') && gameStarted && !gameOver) onJump(); },{passive:true});
  addEventListener('pointerdown', (e)=>{ if(!gameStarted) return; onJump(); }, {passive:true});
  addEventListener('touchstart', (e)=>{ if(!gameStarted) return; onJump(); }, {passive:true});

  // MENU UI wiring
  let mode = 'eterno';
  let minutes = 3;
  let gameStarted = false;
  let startTime = 0;
  let durationSec = Infinity;
  let sinkingStarted = false;
  let gameOver = false;
  let sinkTimeout = null;

  btnEterno.addEventListener('click', ()=>{ mode='eterno'; btnEterno.classList.add('active'); btnEterno.setAttribute('aria-pressed','true'); btnFugaz.classList.remove('active'); btnFugaz.setAttribute('aria-pressed','false'); fugazControls.style.display='none'; });
  btnFugaz.addEventListener('click', ()=>{ mode='fugaz'; btnFugaz.classList.add('active'); btnFugaz.setAttribute('aria-pressed','true'); btnEterno.classList.remove('active'); btnEterno.setAttribute('aria-pressed','false'); fugazControls.style.display='block'; });

  document.getElementById('minUp').addEventListener('click', ()=>{ minutes = Math.min(1440, minutes+1); minutesDisplay.textContent = minutes; });
  document.getElementById('minDown').addEventListener('click', ()=>{ minutes = Math.max(1, minutes-1); minutesDisplay.textContent = minutes; });

  function resetToMenu(){
    // cancel sink timeout
    if(sinkTimeout){ clearTimeout(sinkTimeout); sinkTimeout = null; }

    // show menu, hide overlay
    menu.style.display = 'flex';
    gameOverEl.style.display = 'none';

    // reset flags
    gameOver=false;
    gameStarted=false;
    sinkingStarted=false;
    durationSec = Infinity;
    startTime = 0;

    // recreate clean boat and clear arrays
    boat = new Boat(160);
    boat.agedIntensity = 0;
    boat.sinking = false;
    boat.sinkProgress = 0;

    rocks=[]; drops=[]; ripples=[];
    score = 0;
    hud.textContent = `Score: ${score}`;

    // reflect UI mode buttons
    if(mode === 'fugaz'){
      fugazControls.style.display = 'block';
      btnFugaz.classList.add('active'); btnFugaz.setAttribute('aria-pressed','true');
      btnEterno.classList.remove('active'); btnEterno.setAttribute('aria-pressed','false');
    } else {
      fugazControls.style.display = 'none';
      btnEterno.classList.add('active'); btnEterno.setAttribute('aria-pressed','true');
      btnFugaz.classList.remove('active'); btnFugaz.setAttribute('aria-pressed','false');
    }
  }

  startBtn.addEventListener('click', ()=>{
    // start game
    score = 0; frame = 0; rocks=[]; drops=[]; ripples=[]; sinkingStarted=false; gameOver=false;
    // new fresh boat
    boat = new Boat(160);
    boat.agedIntensity = 0;
    boat.sinking = false;
    boat.sinkProgress = 0;

    if(mode === 'fugaz'){ durationSec = minutes * 60; startTime = performance.now(); }
    else { durationSec = Infinity; startTime = 0; }

    gameStarted = true;
    menu.style.display = 'none';

    tryPlayMusicOnce();
  });

  function tryPlayMusicOnce(){ tryPlayMusicOnceAsync().catch(()=>{}); }
  async function tryPlayMusicOnceAsync(){ if(musicAllowed) return; try{ const p = music.play(); if(p && p.then) await p; musicAllowed = true; musicBtn.classList.remove('muted'); musicBtn.setAttribute('aria-pressed','true'); } catch(e){ /* ignore */ } }

  function formatTime(s){ if(!isFinite(s)) return '--:--'; s = Math.max(0, Math.floor(s)); const mm = Math.floor(s/60); const ss = s%60; return `${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}`; }

  function endGameNow(){
    gameOver = true; gameStarted = false;
    finalScoreEl.textContent = `Puntaje: ${score}`;
    gameOverEl.style.display = 'flex';

    // add one-shot listeners to return to menu
    function anyKeyToMenu(){ resetToMenu(); removeEventListener('keydown', anyKeyToMenu); removeEventListener('pointerdown', anyKeyToMenu); }
    addEventListener('keydown', anyKeyToMenu, {once:true}); addEventListener('pointerdown', anyKeyToMenu, {once:true});
  }

  function initiateSinkingThenEnd(){
    if(sinkingStarted) return;
    sinkingStarted = true;
    boat.sinking = true;
    boat.forceFullyAged();
    // more predictable: use timeout to end
    if(sinkTimeout) clearTimeout(sinkTimeout);
    sinkTimeout = setTimeout(()=>{ endGameNow(); sinkTimeout = null; }, 2600);
  }

  // ----------------- LOOP -----------------
  function loop(){
    const now = performance.now();

    // sky + hills
    const phaseIndex = Math.floor(frame/phaseDurationFrames)%dayPhases.length;
    const phase = dayPhases[phaseIndex];
    const next = dayPhases[(phaseIndex+1)%dayPhases.length];
    const t = (frame % phaseDurationFrames)/phaseDurationFrames;
    const skyColor = lerpColor(phase.sky,next.sky,t);
    ctx.fillStyle = skyColor; ctx.fillRect(0,0,canvas.width,canvas.height);

    for(let i=0;i<hills.length;i++) hills[i].draw(lerpColor(phase.hills[i],next.hills[i],t));

    // river
    const riverBaseColor = lerpColor(phase.river,next.river,t);
    const waterG = ctx.createLinearGradient(0,canvas.height*0.72,0,canvas.height);
    const darken = (rgb,fac=0.85)=>{ const nums = rgb.match(/\d+/g).map(v=>Math.round(parseInt(v)*fac)); return `rgb(${nums[0]},${nums[1]},${nums[2]})`; };
    waterG.addColorStop(0,darken(riverBaseColor,0.97)); waterG.addColorStop(1,darken(riverBaseColor,0.82));
    ctx.beginPath(); for(let x=0;x<=canvas.width;x+=4){ const y=riverY(x); if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); } ctx.lineTo(canvas.width,canvas.height); ctx.lineTo(0,canvas.height); ctx.closePath(); ctx.fillStyle=waterG; ctx.fill();

    // subtle surface stroke
    const surfaceG = ctx.createLinearGradient(0,0,canvas.width,0);
    surfaceG.addColorStop(0,'rgba(255,255,255,0.14)'); surfaceG.addColorStop(1,'rgba(255,255,255,0.05)');
    ctx.strokeStyle = surfaceG; ctx.lineWidth = Math.max(2, Math.round(canvas.width*0.0022));
    ctx.beginPath(); for(let x=0;x<=canvas.width;x+=4){ const y=riverY(x); if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); } ctx.stroke();

    // particles
    particles.forEach(p=>{ p.update(); p.draw(); });

    // drops spawn
    if(frame % 3 === 0 && Math.random() < 0.55){
      if(Math.random() < 0.6) drops.push(new RainDrop()); else drops.push(new SnowFlake());
    }
    for(let i=drops.length-1;i>=0;i--){ const d=drops[i]; d.update(); d.draw(); if(d.hitSurface()){ ripples.push(new Ripple(d.x)); drops.splice(i,1);} else if(d.x<-50||d.x>canvas.width+50||d.y>canvas.height+200) drops.splice(i,1); }
    for(let i=ripples.length-1;i>=0;i--){ const r=ripples[i]; r.update(); r.draw(); if(!r.alive()) ripples.splice(i,1); }

    // rocks
    if(frame%Math.max(60,Math.round(100-Math.min(60,frame*0.001)))===0){ rocks.push(new Rock()); if(rocks.length>22) rocks.shift(); }
    for(let i=rocks.length-1;i>=0;i--){ const r=rocks[i]; r.update(); r.draw(); if(!r.scored && r.collide(boat.rect())){ score-=5; r.scored=true; } else if(!r.scored && (r.cx()+r.r) < (boat.x-boat.w/2)){ score+=10; r.scored=true; } if(r.offscreen()) rocks.splice(i,1); }

    // TEMPORIZADOR Y ENVEJECIMIENTO (VIAJE FUGAZ)
    if(gameStarted && mode==='fugaz' && isFinite(durationSec)){
      const elapsed = (now - startTime)/1000;
      const remaining = Math.max(0, durationSec - elapsed);

      if(boat.sinking){
        // ensure fully aged while sinking
        boat.forceFullyAged();
      } else if(durationSec > 0){
        const startSec = durationSec * clamp(startAt, 0, 1);
        let computed = 0;
        if(elapsed <= startSec){ computed = 0; }
        else if(elapsed >= durationSec){ computed = 1; }
        else {
          const linear = (elapsed - startSec) / Math.max(0.0001, (durationSec - startSec));
          computed = clamp(linear * Math.max(0.01, speedFactor));
        }
        // never decrease agedIntensity during the round
        boat.agedIntensity = Math.max(boat.agedIntensity || 0, computed);
      }

      if(elapsed >= durationSec && !sinkingStarted){ initiateSinkingThenEnd(); }

      hud.textContent = `Tiempo: ${formatTime(Math.max(0, Math.floor(remaining)))} | Score: ${score}`;
    } else {
      hud.textContent = `Score: ${score}`;
    }

    // draw & update boat
    boat.update();
    boat.draw();

    frame++; requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // ----------------- UTIL -----------------
  function formatTime(s){ if(!isFinite(s)) return '--:--'; s = Math.max(0, Math.floor(s)); const mm = Math.floor(s/60); const ss = s%60; return `${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}`; }

  // console warning if mp3 missing
  try{ music.addEventListener('error', ()=>{ console.warn('Audio "drop.mp3" no encontrado o inválido. Coloca drop.mp3 en la misma carpeta o ajustá el src.'); }); }catch(e){}
})();
</script>

</body>
</html>


