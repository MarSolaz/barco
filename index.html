<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<title>Barco de Papel — Zen (lluvia / nieve)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root { --ui-font: 16px/1.2 system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
  html,body{height:100%; margin:0; background:#e6f5ff; font:var(--ui-font); -webkit-font-smoothing:antialiased;}
  canvas{display:block; width:100%; height:100vh;}
  .hud{position:fixed; left:16px; top:12px; color:#111; font-weight:700; text-shadow:0 1px 0 rgba(255,255,255,0.5);}
  /* ocultar la etiqueta del clima (sigue existiendo en el DOM y el script sigue usándola) */
  .subhud{position:fixed; right:16px; top:12px; color:#111; font-weight:600; text-shadow:0 1px 0 rgba(255,255,255,0.5); display:none;}

  /* boton minimalista para musica */
  .music-toggle{position:fixed; right:16px; bottom:16px; width:44px; height:44px; display:flex;align-items:center;justify-content:center;
    background:rgba(255,255,255,0.85); border-radius:10px; box-shadow:0 6px 14px rgba(0,0,0,0.12); cursor:pointer; z-index:40;}
  .music-toggle svg{width:22px;height:22px; display:block}
  .music-toggle.muted{opacity:0.6}
</style>
</head>
<body>

<div class="hud" id="hud">Score: 0</div>
<div class="subhud" id="weatherLabel">Clima: —</div>
<canvas id="game"></canvas>

<!-- Música de fondo -->
<audio id="bgMusic" src="drop.mp3" loop preload="auto"></audio>

<!-- botón minimalista -->
<div class="music-toggle muted" id="musicBtn" title="Activar / desactivar música" aria-pressed="false">
  <!-- icono altavoz con ondas (SVG minimalista) -->
  <svg viewBox="0 0 24 24" aria-hidden="true">
    <g fill="none" stroke="#111" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
      <path d="M5 15V9a1 1 0 0 1 1-1h3l4-4v14l-4-4H6a1 1 0 0 1-1-1z" />
      <path class="wave1" d="M17.5 8.5c1.2 1.2 1.2 3.1 0 4.3" />
      <path class="wave2" d="M19.5 6.5c2 2 2 5.2 0 7.2" />
    </g>
  </svg>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: false });
  const hud = document.getElementById('hud');
  const weatherLabel = document.getElementById('weatherLabel');
  const music = document.getElementById('bgMusic');
  const musicBtn = document.getElementById('musicBtn');

  function fit() { canvas.width = innerWidth; canvas.height = innerHeight; }
  addEventListener('resize', fit, { passive: true });
  fit();

  // try to set a reasonable volume default
  music.volume = 0.28;
  music.loop = true;

  // some browsers block autoplay — we'll attempt to play on first user gesture
  let musicAllowed = false;
  function tryPlayMusic(){ if(musicAllowed) return; try{ const p = music.play(); if(p && p.then) p.then(()=>{ musicAllowed = true; musicBtn.classList.remove('muted'); musicBtn.setAttribute('aria-pressed','true'); }).catch(()=>{/*blocked until gesture*/}); }catch(e){}
  }
  // play on first interaction
  function onFirstGesture(){ tryPlayMusic(); removeEventListener('pointerdown', onFirstGesture); removeEventListener('keydown', onFirstGesture); }
  addEventListener('pointerdown', onFirstGesture, {passive:true});
  addEventListener('keydown', onFirstGesture, {passive:true});

  // toggle button
  function updateMusicUI(){ if(music.paused){ musicBtn.classList.add('muted'); musicBtn.setAttribute('aria-pressed','false'); } else { musicBtn.classList.remove('muted'); musicBtn.setAttribute('aria-pressed','true'); } }
  musicBtn.addEventListener('click', (e)=>{ e.stopPropagation(); if(music.paused){ music.play().catch(()=>{}); } else { music.pause(); } updateMusicUI(); });

  // ---------- Estado ----------
  let frame = 0;
  let score = 0;
  const targetFPS = 60;
  const phaseDurationFrames = targetFPS * 20;
  const weatherDurationFrames = targetFPS * 12;
  const dayPhases = [
    { name:'amanecer', sky:'#FFD9C2', river:'#A7D9FF', hills:['#FFE8B8','#FBD3B3','#FFE0A8'] },
    { name:'día',      sky:'#A6DBF5', river:'#8ECFFF', hills:['#CFF3C9','#BFEFBE','#A7E6A0'] },
    { name:'atardecer',sky:'#FFC7B5', river:'#9FD6FF', hills:['#F6B1B1','#F6D0B1','#F3E3A8'] },
    { name:'noche',    sky:'#142231', river:'#334E7A', hills:['#2B344E','#2E3A5A','#32406A'] }
  ];

  function hexToRgb(h){ h = h.replace('#',''); return {r:parseInt(h.slice(0,2),16), g:parseInt(h.slice(2,4),16), b:parseInt(h.slice(4,6),16)}; }
  function lerpColor(a,b,t){
    const A = hexToRgb(a), B = hexToRgb(b);
    const r = Math.round(A.r + (B.r - A.r) * t);
    const g = Math.round(A.g + (B.g - A.g) * t);
    const bb = Math.round(A.b + (B.b - A.b) * t);
    return `rgb(${r},${g},${bb})`;
  }

  class Hill {
    constructor(baseColor, speed, amp, yFactor){
      this.baseColor = baseColor; this.speed = speed; this.amp = amp; this.yFactor = yFactor;
      this.offset = Math.random() * 1000;
    }
    draw(color){
      this.offset += this.speed;
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(0, canvas.height);
      for(let x=0; x<=canvas.width; x+=6){
        const y = canvas.height * this.yFactor + Math.sin((x * 0.008) + (this.offset*0.01)) * this.amp;
        ctx.lineTo(x, y);
      }
      ctx.lineTo(canvas.width, canvas.height);
      ctx.closePath();
      ctx.fill();
    }
  }

  class Particle {
    constructor(){ this.reset(); }
    reset(){
      this.x = Math.random()*canvas.width;
      this.y = Math.random()*canvas.height;
      this.r = Math.random()*1.6 + 0.6;
      this.vx = (Math.random()-0.5)*0.25;
      this.vy = (Math.random()-0.2)*0.25;
      this.alpha = Math.random()*0.6 + 0.15;
    }
    update(){ this.x += this.vx; this.y += this.vy;
      if(this.x < -10) this.x = canvas.width+10;
      if(this.x > canvas.width+10) this.x = -10;
      if(this.y < -10) this.y = canvas.height+10;
      if(this.y > canvas.height+10) this.y = -10;
    }
    draw(){
      ctx.globalAlpha = this.alpha;
      ctx.beginPath();
      ctx.fillStyle = '#ffffff';
      ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  function riverY(x){
    const t = frame * 0.018;
    return canvas.height * 0.74 + Math.sin(0.009 * x + t) * 24 + Math.sin(0.015 * x + t*0.6) * 8;
  }

  class Boat {
    constructor(x){
      this.x = x;
      this.y = riverY(x) - 30;
      this.w = 72; this.h = 36;
      this.vy = 0;
      this.gravity = 0.8;
      this.jumpForce = -14;
      this.tilt = 0;
    }
    update(){
      this.vy += this.gravity;
      this.y += this.vy;
      const base = riverY(this.x) - this.h;
      if(this.y > base){ this.y = base; this.vy = 0; }
      this.tilt = Math.max(-0.35, Math.min(0.35, this.vy * 0.03));
    }
    draw(phaseRiverColor){
      // shadow
      ctx.save();
      ctx.translate(this.x, this.y + this.h*0.6);
      ctx.rotate(this.tilt * 0.3);
      ctx.globalAlpha = 0.12;
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.ellipse(0, 6, this.w*0.45, 6, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.restore();

      // body
      const gx = ctx.createLinearGradient(this.x - this.w/2, this.y, this.x + this.w/2, this.y + this.h);
      gx.addColorStop(0, '#ffffff'); gx.addColorStop(0.6, '#f1f1f1'); gx.addColorStop(1, '#dcdcdc');

      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(this.tilt);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(this.w*0.45, this.h*0.75);
      ctx.lineTo(this.w*0.06, this.h*0.6);
      ctx.lineTo(-this.w*0.06, this.h*0.6);
      ctx.lineTo(-this.w*0.45, this.h*0.75);
      ctx.closePath();
      ctx.fillStyle = gx;
      ctx.fill();
      ctx.restore();
    }
    jump(){ this.vy = this.jumpForce; }
    rect(){ return { left:this.x-this.w/2, right:this.x+this.w/2, top:this.y, bottom:this.y+this.h }; }
  }

  class Rock {
    constructor(){
      this.r = 12 + Math.random()*20;
      this.x = canvas.width + this.r + Math.random()*200;
      this.speed = 3.6 + Math.random()*0.8;
      this.scored = false;
      this.seed = Math.random()*999;
      this.seed2 = Math.random()*999;
      this.tint = (Math.random()*30-15);
    }
    update(){ this.x -= this.speed; }
    cx(){ return this.x; }
    cy(){ return riverY(this.x) - (this.r * 0.45); }
    offscreen(){ return this.x + this.r < -50; }
    draw(){
      const cx = this.cx(), cy = this.cy();

      // gradient: top is slightly lighter, bottom darker (tendencia a tonos roca más oscuros)
      const g = ctx.createLinearGradient(0, cy - this.r, 0, cy + this.r);
      const top = Math.max(40, 120 + this.tint - 40);
      const mid = Math.max(30, 90 + this.tint - 30);
      const bot = Math.max(10, 40 + this.tint - 40);
      g.addColorStop(0, `rgb(${top},${top},${top})`);
      g.addColorStop(0.6, `rgb(${mid},${mid},${mid})`);
      g.addColorStop(1, `rgb(${bot},${bot},${bot})`);

      ctx.fillStyle = g;
      ctx.beginPath();
      const steps = 34;
      for(let i=0;i<=steps;i++){
        const a = (i/steps) * Math.PI*2;
        const noise = 0.18 * Math.sin(a*3 + this.seed)
                    + 0.10 * Math.sin(a*5 + this.seed2)
                    + 0.06 * Math.sin(a*7 - this.seed*0.3);
        const rad = this.r * (1 + noise);
        const px = cx + Math.cos(a) * rad;
        const py = cy + Math.sin(a) * rad;
        if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.closePath();
      ctx.fill();

      // base ondulada: una pequeña franja en la base que sigue la forma del río para integrar la roca
      ctx.save();
      ctx.beginPath();
      const left = cx - this.r*1.05; const right = cx + this.r*1.05; const step = Math.max(6, Math.round(this.r*0.8));
      for(let x = left; x <= right; x += step){
        const localT = (x - left) / (right - left);
        // ondulación suave con base en riverY y pequeñas variaciones
        const wave = Math.sin((x*0.01) + frame*0.02 + this.seed*0.01) * (this.r*0.18);
        const y = riverY(cx + (x - cx)) - (this.r*0.02) + wave;
        if(x===left) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      }
      // cerrar la franja hacia abajo y rellenar
      ctx.lineTo(right, canvas.height);
      ctx.lineTo(left, canvas.height);
      ctx.closePath();
      ctx.globalAlpha = 0.95;
      // base darker
      ctx.fillStyle = `rgba(${Math.max(8, bot-10)},${Math.max(8, bot-10)},${Math.max(8, bot-10)},1)`;
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.restore();
    }
    collide(boatRect){
      const cx = this.cx(), cy = this.cy(), r = this.r;
      const closestX = Math.max(boatRect.left, Math.min(cx, boatRect.right));
      const closestY = Math.max(boatRect.top, Math.min(cy, boatRect.bottom));
      const dx = cx - closestX, dy = cy - closestY;
      return (dx*dx + dy*dy) <= (r * r);
    }
  }

  class RainDrop {
    constructor(){ this.reset(); }
    reset(){
      this.x = Math.random()*canvas.width;
      this.y = -10 - Math.random()*200;
      this.vy = 8 + Math.random()*6;
      this.len = 8 + Math.random()*10;
      this.alpha = 0.2 + Math.random()*0.4;
    }
    update(){ this.x += (Math.random()-0.5)*0.6; this.y += this.vy; }
    draw(){
      ctx.globalAlpha = this.alpha;
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(255,255,255,0.65)';
      ctx.lineWidth = 1;
      ctx.moveTo(this.x, this.y);
      ctx.lineTo(this.x, this.y + this.len);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }
    hitSurface(){ return this.y >= riverY(this.x); }
  }

  class SnowFlake {
    constructor(){ this.x = Math.random()*canvas.width; this.y = -10-Math.random()*200;
      this.vy = 0.6 + Math.random()*1.2; this.vx = (Math.random()-0.5)*0.6;
      this.r = 1.8 + Math.random()*2.6; this.alpha = 0.6 + Math.random()*0.4;
    }
    update(){ this.x += this.vx; this.y += this.vy; this.vx += (Math.random()-0.5)*0.04; }
    draw(){ ctx.globalAlpha = this.alpha; ctx.beginPath(); ctx.fillStyle='rgba(255,255,255,0.95)';
      ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; }
    hitSurface(){ return this.y >= riverY(this.x); }
  }

  class Ripple {
    constructor(x){ this.x=x; this.y=riverY(x); this.r=2+Math.random()*2; this.life=0.9; }
    update(){ this.r += 0.9 + Math.random()*0.6; this.life -= 0.06; if(this.life<0)this.life=0; }
    draw(){ if(this.life<=0) return;
      ctx.globalAlpha=this.life*0.9; ctx.strokeStyle='rgba(255,255,255,0.35)'; ctx.lineWidth=Math.max(1,this.life*2);
      ctx.beginPath(); ctx.ellipse(this.x,this.y+2,this.r*1.1,this.r*0.4,0,0,Math.PI*2); ctx.stroke(); ctx.globalAlpha=1;
    }
    alive(){ return this.life>0.02; }
  }

  const boat = new Boat(160);
  const hills = [ new Hill('#000', 0.15, 28, 0.45), new Hill('#000', 0.28, 18, 0.55), new Hill('#000', 0.55, 12, 0.66) ];
  const particles = Array.from({length:90},()=>new Particle());
  let rocks = [], drops=[], ripples=[];

  const weatherTypes = ['lluvia','nieve'];
  function currentWeather(){ return weatherTypes[Math.floor(frame/weatherDurationFrames)%weatherTypes.length]; }

  function onJump(){ boat.jump(); }
  addEventListener('keydown',()=>onJump(),{passive:true});
  addEventListener('pointerdown',onJump,{passive:true});
  addEventListener('touchstart',onJump,{passive:true});

  function loop(){
    const phaseIndex = Math.floor(frame/phaseDurationFrames)%dayPhases.length;
    const phase = dayPhases[phaseIndex];
    const next = dayPhases[(phaseIndex+1)%dayPhases.length];
    const t = (frame % phaseDurationFrames)/phaseDurationFrames;
    const skyColor = lerpColor(phase.sky,next.sky,t);
    ctx.fillStyle=skyColor; ctx.fillRect(0,0,canvas.width,canvas.height);

    for(let i=0;i<hills.length;i++) hills[i].draw(lerpColor(phase.hills[i],next.hills[i],t));

    const riverBaseColor = lerpColor(phase.river,next.river,t);
    const waterG = ctx.createLinearGradient(0,canvas.height*0.72,0,canvas.height);
    const darken = (rgb,fac=0.85)=>{ const n=rgb.match(/\d+/g).map(v=>Math.round(parseInt(v)*fac)); return `rgb(${n[0]},${n[1]},${n[2]})`; };
    waterG.addColorStop(0,darken(riverBaseColor,0.97));
    waterG.addColorStop(1,darken(riverBaseColor,0.82));
    ctx.beginPath(); for(let x=0;x<=canvas.width;x+=4){ const y=riverY(x); if(x===0)ctx.moveTo(x,y); else ctx.lineTo(x,y);} 
    ctx.lineTo(canvas.width,canvas.height); ctx.lineTo(0,canvas.height); ctx.closePath(); ctx.fillStyle=waterG; ctx.fill();

    const surfaceG = ctx.createLinearGradient(0,0,canvas.width,0);
    surfaceG.addColorStop(0,'rgba(255,255,255,0.14)'); surfaceG.addColorStop(1,'rgba(255,255,255,0.05)');
    ctx.strokeStyle=surfaceG; ctx.lineWidth=Math.max(2,Math.round(canvas.width*0.0022));
    ctx.beginPath(); for(let x=0;x<=canvas.width;x+=4){ const y=riverY(x); if(x===0)ctx.moveTo(x,y); else ctx.lineTo(x,y); } ctx.stroke();

    particles.forEach(p=>{p.update();p.draw();});

    const weather = currentWeather();
    // la etiqueta visual del clima está oculta, pero seguimos calculando el clima y usando su valor para los efectos
    weatherLabel.textContent = `Clima: ${weather==='lluvia'?'Lluvia':'Nieve'}`;
    if(weather==='lluvia'){ if(Math.random()<0.9) drops.push(Object.assign(new RainDrop(),{type:'rain'})); }
    else{ if(Math.random()<0.35) drops.push(Object.assign(new SnowFlake(),{type:'snow'})); }

    for(let i=drops.length-1;i>=0;i--){
      const d=drops[i]; d.update(); d.draw();
      if(d.hitSurface()){ ripples.push(new Ripple(d.x)); drops.splice(i,1);} 
      else if(d.x<-50||d.x>canvas.width+50||d.y>canvas.height+200) drops.splice(i,1);
    }

    for(let i=ripples.length-1;i>=0;i--){ const r=ripples[i]; r.update(); r.draw(); if(!r.alive()) ripples.splice(i,1); }

    if(frame%Math.max(60,Math.round(100-Math.min(60,frame*0.001)))===0){ rocks.push(new Rock()); if(rocks.length>22) rocks.shift(); }

    for(let i=rocks.length-1;i>=0;i--){
      const r=rocks[i]; r.update(); r.draw();
      if(!r.scored && r.collide(boat.rect())){ score-=5; r.scored=true; }
      else if(!r.scored && (r.cx()+r.r)<(boat.x-boat.w/2)){ score+=10; r.scored=true; }
      if(r.offscreen()) rocks.splice(i,1);
    }

    boat.update(); boat.draw(riverBaseColor);
    hud.textContent=`Score: ${score}`;
    frame++; requestAnimationFrame(loop);
  }
  loop();
})();
</script>
</body>
</html>

